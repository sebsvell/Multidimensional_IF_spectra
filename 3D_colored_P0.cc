/*This program calculates the stationary density of a leaky integrate-and-fire neuron driven by colored noise that is generated by a two-dimensional Ornstein_uhlenbeck process
(see Vellmer and Lindern 2019). The solution is used to calculate the self-consistent spike-train power spectrum as it appears in network simulations. As input, a file coef.txt 
is required that determines the coefficients of the Ornstein-Uhlenbeck process as well as the matrices of the propagator function that is required for a non-zero refractory period.
For the solution of the resulting large system the Eigen Package for sparse linear Algebra is employed. The program saves three outputs: the firing rate, the stationary density 
as a long one-dimensional array and a file with the used parameters.  

author: Sebastian Vellmer
sebastian.vellmer@bccn-berlin.de
*/




#include <fstream>
#include <iostream>
#include <ctime>
#include <cmath>
#include "/Eigen/Sparse"

int main(int argc, char* argv[]){
	std::ofstream outFile;	
	/*neuron parameters*/
	double tau_m=0.02;
	double vth=20.0;
	double tref=0.002;
	
	double J=0.4;
	double g=4.5;
	int CE=500;
	int CI=125;
	double alpha=tau_m*tau_m*J*J*(CE+CI*g*g);
	double mu=1./alpha*tau_m*J*(CE-CI*g);
	
    std::ifstream myfile;
    myfile.open("coef.txt");
    double par[21];
    float a;
    int i=0;
    while (myfile >> a)
    {
        par[i]=a;
        ++i;
    }
	double a11=par[0];
	double a12=par[1];
	double a21=par[2];
	double a22=par[3];
	double b11=par[4];
	double b12=par[5];
	double b21=par[6];
	double b22=par[7];
	double beta1=par[8];
	double beta2=par[9];
	double a1_N_1=par[10];
	double a2_N_1=par[11];
	double G11=par[12];
	double G12=par[13];
	double G21=par[14];
	double G22=par[15];
	alpha=par[16];
	double sig11=par[17];
	double sig12=par[18];
	double sig21=par[19];
	double sig22=par[20];
	
	mu=30.+(beta1*beta1+beta2*beta2)*mu;
	
	//area parameters
	double vr=0.0;
	double v0=-25.;
	int N_v=500;
	
	double a1_0=-a1_N_1;
	//double a1_N_1=100.;
	int N_a1=100;
	
	double a2_0=-a2_N_1;
	//double a2_N_1=100.;
	int N_a2=100;

	int N_ele=N_v*N_a1*N_a2;
	
	std::cout << "initialize operator \n";
	std::clock_t start= std::clock();
	//v-space
	Eigen::VectorXd v;
	double dv=(vth-v0)/(N_v);
	v.setLinSpaced(N_v,v0,vth-dv);
	int nr=(vr-v(0))/dv;
	
	//a1-space
	Eigen::VectorXd a1;
	a1.setLinSpaced(N_a1,a1_0,a1_N_1);
	double da1=a1(1)-a1(0);
	
	//a2-space
	Eigen::VectorXd a2;
	a2.setLinSpaced(N_a2,a2_0,a2_N_1);
	double da2=a2(1)-a2(0);
	
	//Fokker-Planck operatore entries
	double vv=(beta1*beta1+beta2*beta2)/tau_m/tau_m/2./dv/dv;
	double aa1=(b11*b11+b12*b12)/2./da1/da1;
	double aa2=(b21*b21+b22*b22)/2./da2/da2;
	double diag=-2.*vv-2.*aa1-2.*aa2;
	Eigen::VectorXd c1(N_v);
	Eigen::VectorXd c2(N_a1);
	Eigen::VectorXd c3(N_a2);

	Eigen::VectorXd right(N_ele);
	Eigen::VectorXd P0(N_ele);
	Eigen::VectorXi res(N_ele);
	for (int i=0; i<N_ele; ++i){
		res[i]=30;
	}
	Eigen::SparseMatrix <double> L(N_ele,N_ele);
	L.reserve(res);
	Eigen::SparseMatrix <double> Jth(N_ele,N_ele);
	Eigen::SparseMatrix <double> one(N_ele,N_ele);
	int vloc [N_v];
	int a1loc [N_a1];
	int a2loc [N_a2];
	std::cout << "set diagonal \n";
    for (int i=0; i<N_ele; ++i){    
		L.insert(i,i)=diag;
		right[i]=1.;
	}
	for (int i=0; i<N_v; ++i){
		vloc[i]=i;
        c1[i]=(v[i]-mu)/2./tau_m/dv;
	}
	for (int i=0; i<N_a1; ++i){
		a1loc[i]=i*N_v;
        c2[i]=-a1[i]/2./tau_m/dv;
	}
	for (int i=0; i<N_a2; ++i){
		a2loc[i]=i*N_v*N_a1;
        c3[i]=-a2[i]/2./tau_m/dv;
	}
	std::cout << "set v-derivatives \n";
	for (int j=0;j<N_a1;++j){
		std::cout<<j*100./N_a1<<"\t %"<<std::endl;
		for (int i=0;i<N_a2;++i){
			for (int k=0;k<N_v-1;++k){
				L.insert(vloc[k]+a1loc[j]+a2loc[i],vloc[k+1]+a1loc[j]+a2loc[i])=vv+c1[k+1]+c2[j]+c3[i];
				L.insert(vloc[k+1]+a1loc[j]+a2loc[i],vloc[k]+a1loc[j]+a2loc[i])=vv-c1[k]-c2[j]-c3[i];
			}
		}
	}
	for (int i=0; i<N_a1; ++i){
        c2[i]=a11*a1[i]/2./da1;
	}
	for (int i=0; i<N_a2; ++i){
        c3[i]=a12*a2[i]/2./da1;
	}
	std::cout << "set a1-derivatives \n";
	for (int j=0;j<N_a1-1;++j){
		std::cout<<j*100./N_a1<<"\t %"<<std::endl;
		for (int i=0;i<N_a2;++i){
			for (int k=0;k<N_v;++k){
				L.insert(vloc[k]+a1loc[j]+a2loc[i],vloc[k]+a1loc[j+1]+a2loc[i])=aa1+c2[j+1]+c3[i];
				L.insert(vloc[k]+a1loc[j+1]+a2loc[i],vloc[k]+a1loc[j]+a2loc[i])=aa1-c2[j]-c3[i];
			}
		}
	}
	for (int i=0; i<N_a1; ++i){
        c2[i]=a21*a1[i]/2./da2;
	}
	for (int i=0; i<N_a2; ++i){
        c3[i]=a22*a2[i]/2./da2;
	}
	std::cout << "set a2-derivatives \n";
	for (int j=0;j<N_a1;++j){
		std::cout<<j*100./N_a2<<"\t %"<<std::endl;
		for (int i=0;i<N_a2-1;++i){
			for (int k=0;k<N_v;++k){
				L.insert(vloc[k]+a1loc[j]+a2loc[i],vloc[k]+a1loc[j]+a2loc[i+1])=aa2+c2[j]+c3[i+1];
				L.insert(vloc[k]+a1loc[j]+a2loc[i+1],vloc[k]+a1loc[j]+a2loc[i])=aa2-c2[j]-c3[i];
			}
		}
	}
	std::cout << "set v-a1-derivatives \n";
	double cros=(beta1*b11+beta2*b12)/4./tau_m/dv/da1;
	if (cros!=0.){
		for (int j=0;j<N_a1-1;++j){
			std::cout<<j*100./N_a1<<"\t %"<<std::endl;
			for (int i=0;i<N_a2;++i){
				for (int k=0;k<N_v-1;++k){
					L.insert(vloc[k+1]+a1loc[j]+a2loc[i],vloc[k]+a1loc[j+1]+a2loc[i])=-cros;
					L.insert(vloc[k]+a1loc[j]+a2loc[i],vloc[k+1]+a1loc[j+1]+a2loc[i])=cros;
					L.insert(vloc[k+1]+a1loc[j+1]+a2loc[i],vloc[k]+a1loc[j]+a2loc[i])=cros;
					L.insert(vloc[k]+a1loc[j+1]+a2loc[i],vloc[k+1]+a1loc[j]+a2loc[i])=-cros;
				}
			}
		}
	}
	std::cout << "set v-a2-derivatives \n";
	cros=(beta1*b21+beta2*b22)/4./tau_m/dv/da2;
	if (cros!=0.){
		for (int j=0;j<N_a1;++j){
			std::cout<<j*100./N_a1<<"\t %"<<std::endl;
			for (int i=0;i<N_a2-1;++i){
				for (int k=0;k<N_v-1;++k){
					L.insert(vloc[k+1]+a1loc[j]+a2loc[i],vloc[k]+a1loc[j]+a2loc[i+1])=-cros;
					L.insert(vloc[k]+a1loc[j]+a2loc[i],vloc[k+1]+a1loc[j]+a2loc[i+1])=cros;
					L.insert(vloc[k+1]+a1loc[j]+a2loc[i+1],vloc[k]+a1loc[j]+a2loc[i])=cros;
					L.insert(vloc[k]+a1loc[j]+a2loc[i+1],vloc[k+1]+a1loc[j]+a2loc[i])=-cros;
				}
			}
		}
	}
	std::cout << "set a1-a2-derivatives \n";
	cros=(b11*b21+b12*b22)/4./da1/da2;
	if (cros!=0.){
		for (int j=0;j<N_a1-1;++j){
			std::cout<<j*100./N_a1<<"\t %"<<std::endl;
			for (int i=0;i<N_a2-1;++i){
				for (int k=0;k<N_v;++k){
					L.insert(vloc[k]+a1loc[j+1]+a2loc[i],vloc[k]+a1loc[j]+a2loc[i+1])=-cros;
					L.insert(vloc[k]+a1loc[j]+a2loc[i],vloc[k]+a1loc[j+1]+a2loc[i+1])=cros;
					L.insert(vloc[k]+a1loc[j+1]+a2loc[i+1],vloc[k]+a1loc[j]+a2loc[i])=cros;
					L.insert(vloc[k]+a1loc[j]+a2loc[i+1],vloc[k]+a1loc[j+1]+a2loc[i])=-cros;
				}
			}
		}
	}		
	L.makeCompressed();
	
	for (int i=0;i<N_ele;++i){
		one.insert(i,nr+a1loc[N_a1/2]+a2loc[N_a2/2])=1.;
	}
	std::cout << "L initialized" << std::endl;
	std::cout << "initialize R" << std::endl;
	if (tref>0.){
		for (int i=0; i<N_ele; ++i){
			res[i]=0;
		}
		Eigen::Matrix2d sig;
		sig<<sig11,sig12,sig21,sig22;
		Eigen::Vector2d vec;
		double Alpha=alpha*da1*da2;
		double pp;
		double p;
		double cutoff=14.;	//this parameter is used to neglects all entries of the propagator function during the refractory period that are smaller than exp(-cutoff/2) in order to increase the efficacy of the program
		Eigen::VectorXd PP (N_a1*N_a2);
		int kappa;
		for (int k=0.;k<N_a1;k++){
			for (int l=0.;l<N_a2;l++){
				pp=0;
				kappa=0;
				for (int i=0;i<N_a1;i++){
					std::clock_t start=std::clock();
					for (int j=0;j<N_a2;j++){					
						vec(0)=a1[i]-G11*a1[k]-G12*a2[l];
						vec(1)=a2[j]-G21*a1[k]-G22*a2[l];
						p=vec.transpose()*sig*vec;
						if (p<cutoff){
							p=std::exp(-0.5*p);						
							kappa+=1;						
							pp+=p;
						}
					}
				}
				res[a1loc[k]+a2loc[l]+N_v-1]=kappa;
				PP[k+N_a1*l]=1./(pp*Alpha);
			}
			std::cout<<k*100./N_a1<<"\t %"<<std::endl;
			std::clock_t end=std::clock();
			std::cout<<(end-start)/1000000.<<std::endl;
		}
		std::cout << "reserve calculated"<<std::endl;
		Jth.reserve(res);
		Alpha=Alpha*vv;
		for (int l=0;l<N_a2;l++){
			for (int k=0;k<N_a1;k++){					
				std::clock_t start=std::clock();
				pp=0;
				for (int j=0.;j<N_a2;j++){
					for (int i=0.;i<N_a1;i++){		
						vec(0)=a1[i]-G11*a1[k]-G12*a2[l];
						vec(1)=a2[j]-G21*a1[k]-G22*a2[l];
						p=vec.transpose()*sig*vec;
						if (p<cutoff){
							Jth.insert(nr+a1loc[i]+a2loc[j],a1loc[k]+a2loc[l]+N_v-1)=Alpha*std::exp(-0.5*p);//*PP[k+N_a1*l];
						}
					}
				}
			}
			std::cout<<l*100./N_a1<<"\t %"<<std::endl;
			std::clock_t end=std::clock();
			std::cout<<(end-start)/1000000.<<std::endl;
		}
	}
	
	else{
		for (int i=0;i<N_a1;i++){
			for (int j=0;j<N_a2;j++){
				Jth.insert(nr+a1loc[i]+a2loc[j],a1loc[i]+a2loc[j]+N_v-1)=vv;
			}
		}
	}
	Jth.makeCompressed();
	std::clock_t end=std::clock();
	std::cout<<(end-start)/1000000.<<std::endl;
	std::cout << "stationary solution"<<std::endl;
	start= std::clock();
	res.resize(0);
	c1.resize(0);
	c2.resize(0);
	c3.resize(0);
	
	Eigen::BiCGSTAB <Eigen::SparseMatrix<double>,Eigen::IncompleteLUT<double> > solver;
	solver.preconditioner().setDroptol(0.001);
    solver.preconditioner().setFillfactor(15);
    //Eigen::BiCGSTAB <Eigen::SparseMatrix<double> > solver;
	solver.compute(L+Jth+one);
	end=std::clock();
	std::cout<<(end-start)/1000000.<<std::endl;
	P0=solver.solve(right);
    std::cout << "#iterations:     " << solver.iterations() << std::endl;
	std::cout << "estimated error: " << solver.error()      << std::endl;
	end=std::clock();
	std::cout<<(end-start)/1000000.<<std::endl;
	for(int j=0; j<N_v*N_a1*N_a2; j++){
		if (P0[i]<0){
			P0[i]=0;
		}
	}
	P0=1./dv/da1/da2/P0.sum()*P0;
	Eigen::VectorXd Ps (N_ele);
	double rate=0;
	for (int i=0;i<N_a1;i++){
		for (int j=0;j<N_a2;j++){
			rate+=P0[a1loc[i]+a2loc[j]+N_v-1];
		}
	}
	rate=rate*vv*dv*da1*da2;
	std::cout<<rate<<std::endl;
	rate=1./(tref+1./rate);
	outFile.open("rate.txt");
	outFile<<rate<<std::endl;
	outFile.close();
	std::cout<<"rate: \t"<< rate <<std::endl;
	P0=P0*(1.-tref*rate);
	outFile.open("P0.txt");
	for (int i=0; i<N_ele; i++){
		outFile<<P0[i]<<std::endl;
	}
	outFile.close();
	outFile.open("params.txt");
	outFile<<N_v<<"\n";
	outFile<<N_a1<<"\n";
	outFile<<N_a2<<"\n";
	outFile<<v0<<"\n";
	outFile<<vth<<"\n";
	outFile<<a1_0<<"\n";
	outFile<<a1_N_1<<"\n";
	outFile<<a2_0<<"\n";
	outFile<<a2_N_1<<"\n";
	outFile.close();
	
	return 0;
}

