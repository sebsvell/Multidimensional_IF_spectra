/*This program calculates the spike-train power spectrum of a leaky integrate-and-fire neuron driven by colored noise that is generated by a two-dimensional Ornstein_uhlenbeck process
(see Vellmer and Lindern 2019) at the frequencies given below. For the calculation the stationary density and the firing rate is required from the program 3D_colored_P0.cc. As input, 
a file coef.txt is required that determines the coefficients of the Ornstein-Uhlenbeck process as well as the matrices of the propagator function that is required for a non-zero 
refractory period. For the solution of the resulting large system the Eigen Package for sparse linear Algebra is employed. As the result, the program saves the fourier transformed 
conditional firing rate. To obtain the power spectrum, the specturm follows according to s=rate*(1+m).

author: Sebastian Vellmer
sebastian.vellmer@bccn-berlin.de
*/

#include <fstream>
#include <iostream>
#include <complex>
#include <ctime>
#include <cmath>
#include "/home/sebastian/3D_self_cons/Eigen/Sparse"

int main(int argc, char* argv[]){
	std::ofstream outFile;
    std::ifstream myfile;
    std::ifstream myfile1;

    float a;
	double rate=0;
	myfile.open("rate.txt");
	myfile>>a;
	rate=a;
	myfile.close();
	std::cout<<"rate:\t"<<rate<<std::endl;
	    
	//Frequency parameters
	int n_omega=5;
	Eigen::VectorXd omega(n_omega);
	omega[0]=0;
	omega[1]=rate/4*6.283185307179586;
	omega[2]=rate/2.*6.283185307179586;
	omega[3]=rate*6.283185307179586;
	omega[4]=rate*2.*6.283185307179586;
	
	Eigen::VectorXcd c_omega (n_omega);
	for (int i=0; i<n_omega; i++){
		c_omega[i]=1j*omega[i];
	}



	/*neuron parameters*/
	double tau_m=0.02;
	double vth=20.0;
	double tref=0.002;
	double vr=0.;
	
	double J=0.4;
	double g=4.5;
	int CE=500;
	int CI=125;
	double alpha=tau_m*tau_m*J*J*(CE+CI*g*g);
	double mu=1./alpha*tau_m*J*(CE-CI*g);
    myfile.open("coef.txt");
    double par[21];
    int i=0;
    while (myfile >> a)
    {
        par[i]=a;
        ++i;
    }
	double a11=par[0];
	double a12=par[1];
	double a21=par[2];
	double a22=par[3];
	double b11=par[4];
	double b12=par[5];
	double b21=par[6];
	double b22=par[7];
	double beta1=par[8];
	double beta2=par[9];
	double G11=par[12];
	double G12=par[13];
	double G21=par[14];
	double G22=par[15];
	alpha=par[16];
	double sig11=par[17];
	double sig12=par[18];
	double sig21=par[19];
	double sig22=par[20];
	myfile.close();
	
	mu=30.+(beta1*beta1+beta2*beta2)*mu;
	
	myfile.open("params.txt");
	i=0;
	while (myfile >> a)
    {
        par[i]=a;
        ++i;
    }
	myfile.close();
    int N_v=par[0];
    int N_a1=par[1];
    int N_a2=par[2];
    double v0=par[3];
    vth=par[4];
    double a1_0=par[5];
    double a1_N_1=par[6];
    double a2_0=par[7];
    double a2_N_1=par[8];
	myfile1.close();
	
	int N_ele=N_v*N_a1*N_a2;
	
	std::cout << "initialize operator \n";
	std::clock_t start= std::clock();
	//v-space
	Eigen::VectorXd v;
	double dv=(vth-v0)/(N_v);
	v.setLinSpaced(N_v,v0,vth-dv);
	int nr=(vr-v(0))/dv;
	
	//y-space
	Eigen::VectorXd a1;
	a1.setLinSpaced(N_a1,a1_0,a1_N_1);
	double da1=a1(1)-a1(0);
	for (int i =0; i<9;i++){
		std::cout<<par[i]<<std::endl;
	}
	//z-space
	Eigen::VectorXd a2;
	a2.setLinSpaced(N_a2,a2_0,a2_N_1);
	double da2=a2(1)-a2(0);
	
	//Fokker-Planck operatore entries
	double vv=(beta1*beta1+beta2*beta2)/tau_m/tau_m/2./dv/dv;
	double aa1=(b11*b11+b12*b12)/2./da1/da1;
	double aa2=(b21*b21+b22*b22)/2./da2/da2;
	double diag=-2.*vv-2.*aa1-2.*aa2;
	Eigen::VectorXd c1(N_v);
	Eigen::VectorXd c2(N_a1);
	Eigen::VectorXd c3(N_a2);

	Eigen::VectorXcd right(N_ele);
	Eigen::VectorXcd P0(N_ele);
	Eigen::VectorXi res(N_ele);
	for (int i=0; i<N_ele; ++i){
		res[i]=30;
	}
	
	Eigen::SparseMatrix <std::complex<double>> L(N_ele,N_ele);
	L.reserve(res);
	Eigen::SparseMatrix <std::complex<double>> Jth(N_ele,N_ele);
	int vloc [N_v];
	int a1loc [N_a1];
	int a2loc [N_a2];
	std::cout << "set diagonal \n";
    for (int i=0; i<N_ele; ++i){    
		L.insert(i,i)=diag;
		right[i]=1.;
	}

	for (int i=0; i<N_v; ++i){
		vloc[i]=i;
        c1[i]=(v[i]-mu)/2./tau_m/dv;
	}
	for (int i=0; i<N_a1; ++i){
		a1loc[i]=i*N_v;
        c2[i]=-a1[i]/2./tau_m/dv;
	}
	for (int i=0; i<N_a2; ++i){
		a2loc[i]=i*N_v*N_a1;
        c3[i]=-a2[i]/2./tau_m/dv;
	}
	std::cout << "set v-derivatives \n";
	for (int j=0;j<N_a1;++j){
		std::cout<<j*100./N_a1<<"\t %"<<std::endl;
		for (int i=0;i<N_a2;++i){
			for (int k=0;k<N_v-1;++k){
				L.insert(vloc[k]+a1loc[j]+a2loc[i],vloc[k+1]+a1loc[j]+a2loc[i])=vv+c1[k+1]+c2[j]+c3[i];
				L.insert(vloc[k+1]+a1loc[j]+a2loc[i],vloc[k]+a1loc[j]+a2loc[i])=vv-c1[k]-c2[j]-c3[i];
			}
		}
	}
	for (int i=0; i<N_a1; ++i){
        c2[i]=a11*a1[i]/2./da1;
	}
	for (int i=0; i<N_a2; ++i){
        c3[i]=a12*a2[i]/2./da1;
	}
	std::cout << "set a1-derivatives \n";
	for (int j=0;j<N_a1-1;++j){
		std::cout<<j*100./N_a1<<"\t %"<<std::endl;
		for (int i=0;i<N_a2;++i){
			for (int k=0;k<N_v;++k){
				L.insert(vloc[k]+a1loc[j]+a2loc[i],vloc[k]+a1loc[j+1]+a2loc[i])=aa1+c2[j+1]+c3[i];
				L.insert(vloc[k]+a1loc[j+1]+a2loc[i],vloc[k]+a1loc[j]+a2loc[i])=aa1-c2[j]-c3[i];
			}
		}
	}
	for (int i=0; i<N_a1; ++i){
        c2[i]=a21*a1[i]/2./da2;
	}
	for (int i=0; i<N_a2; ++i){
        c3[i]=a22*a2[i]/2./da2;
	}
	std::cout << "set a2-derivatives \n";
	for (int j=0;j<N_a1;++j){
		std::cout<<j*100./N_a2<<"\t %"<<std::endl;
		for (int i=0;i<N_a2-1;++i){
			for (int k=0;k<N_v;++k){
				L.insert(vloc[k]+a1loc[j]+a2loc[i],vloc[k]+a1loc[j]+a2loc[i+1])=aa2+c2[j]+c3[i+1];
				L.insert(vloc[k]+a1loc[j]+a2loc[i+1],vloc[k]+a1loc[j]+a2loc[i])=aa2-c2[j]-c3[i];
			}
		}
	}
	
	std::cout << "set v-a1-derivatives \n";
	double cros=(beta1*b11+beta2*b12)/4./tau_m/dv/da1;
	if (cros!=0.){
		for (int j=0;j<N_a1-1;++j){
			std::cout<<j*100./N_a1<<"\t %"<<std::endl;
			for (int i=0;i<N_a2;++i){
				for (int k=0;k<N_v-1;++k){
					L.insert(vloc[k+1]+a1loc[j]+a2loc[i],vloc[k]+a1loc[j+1]+a2loc[i])=-cros;
					L.insert(vloc[k]+a1loc[j]+a2loc[i],vloc[k+1]+a1loc[j+1]+a2loc[i])=cros;
					L.insert(vloc[k+1]+a1loc[j+1]+a2loc[i],vloc[k]+a1loc[j]+a2loc[i])=cros;
					L.insert(vloc[k]+a1loc[j+1]+a2loc[i],vloc[k+1]+a1loc[j]+a2loc[i])=-cros;
				}
			}
		}
	}
	std::cout << "set v-a2-derivatives \n";
	cros=(beta1*b21+beta2*b22)/4./tau_m/dv/da2;
	if (cros!=0.){
		for (int j=0;j<N_a1;++j){
			std::cout<<j*100./N_a1<<"\t %"<<std::endl;
			for (int i=0;i<N_a2-1;++i){
				for (int k=0;k<N_v-1;++k){
					L.insert(vloc[k+1]+a1loc[j]+a2loc[i],vloc[k]+a1loc[j]+a2loc[i+1])=-cros;
					L.insert(vloc[k]+a1loc[j]+a2loc[i],vloc[k+1]+a1loc[j]+a2loc[i+1])=cros;
					L.insert(vloc[k+1]+a1loc[j]+a2loc[i+1],vloc[k]+a1loc[j]+a2loc[i])=cros;
					L.insert(vloc[k]+a1loc[j]+a2loc[i+1],vloc[k+1]+a1loc[j]+a2loc[i])=-cros;
				}
			}
		}
	}
	std::cout << "set a1-a2-derivatives \n";
	cros=(b11*b21+b12*b22)/4./da1/da2;
	if (cros!=0.){
		for (int j=0;j<N_a1-1;++j){
			std::cout<<j*100./N_a1<<"\t %"<<std::endl;
			for (int i=0;i<N_a2-1;++i){
				for (int k=0;k<N_v;++k){
					L.insert(vloc[k]+a1loc[j+1]+a2loc[i],vloc[k]+a1loc[j]+a2loc[i+1])=-cros;
					L.insert(vloc[k]+a1loc[j]+a2loc[i],vloc[k]+a1loc[j+1]+a2loc[i+1])=cros;
					L.insert(vloc[k]+a1loc[j+1]+a2loc[i+1],vloc[k]+a1loc[j]+a2loc[i])=cros;
					L.insert(vloc[k]+a1loc[j]+a2loc[i+1],vloc[k]+a1loc[j+1]+a2loc[i])=-cros;
				}
			}
		}		
	}	
	L.makeCompressed();
	
	std::cout << "L initialized" << std::endl;
	std::cout << "initialize R" << std::endl;
	if (tref>0.){
		for (int i=0; i<N_ele; ++i){
			res[i]=0;
		}
		Eigen::Matrix2d sig;
		sig<<sig11,sig12,sig21,sig22;
		Eigen::Vector2d vec;
		double Alpha=alpha*da1*da2;
		double pp;
		double p;
		double cutoff=14.;
		Eigen::VectorXd PP (N_a1*N_a2);
		int kappa;
		for (int k=0.;k<N_a1;k++){
			for (int l=0.;l<N_a2;l++){
				pp=0;
				kappa=0;
				for (int i=0;i<N_a1;i++){
					std::clock_t start=std::clock();
					for (int j=0;j<N_a2;j++){					
						vec(0)=a1[i]-G11*a1[k]-G12*a2[l];
						vec(1)=a2[j]-G21*a1[k]-G22*a2[l];
						p=vec.transpose()*sig*vec;
						if (p<cutoff){
							p=std::exp(-0.5*p);						
							kappa+=1;						
							pp+=p;
						}
					}
				}
				//std::cout<<pp*alpha*da1*da2<<std::endl;
				//std::cout<<kappa<<std::endl
				res[a1loc[k]+a2loc[l]+N_v-1]=kappa;
				PP[k+N_a1*l]=1./(pp*Alpha);
			}
			std::cout<<k*100./N_a1<<"\t %"<<std::endl;
			std::clock_t end=std::clock();
			std::cout<<(end-start)/1000000.<<std::endl;
		}
		std::cout << "reserve calculated"<<std::endl;
		Jth.reserve(res);
		Alpha=Alpha*vv;
		for (int k=0.;k<N_a1;k++){
			for (int l=0.;l<N_a2;l++){
				pp=0;
				kappa=0;
				for (int i=0;i<N_a1;i++){
					std::clock_t start=std::clock();
					for (int j=0;j<N_a2;j++){					
						vec(0)=a1[i]-G11*a1[k]-G12*a2[l];
						vec(1)=a2[j]-G21*a1[k]-G22*a2[l];
						p=vec.transpose()*sig*vec;
						if (p<cutoff){
							Jth.insert(nr+a1loc[i]+a2loc[j],a1loc[k]+a2loc[l]+N_v-1)=Alpha*std::exp(-0.5*p);//*PP[k+N_a1*l];
						}
					}
				}
			}
			std::cout<<k*100./N_a1<<"\t %"<<std::endl;
			std::clock_t end=std::clock();
			std::cout<<(end-start)/1000000.<<std::endl;
		}
		PP.resize(0);
	}
	
	else{
		for (int i=0;i<N_a1;i++){
			for (int j=0;j<N_a2;j++){
				Jth.insert(nr+a1loc[i]+a2loc[j],a1loc[i]+a2loc[j]+N_v-1)=vv;
			}
		}
	}
	Jth.makeCompressed();
	res.resize(0);
	c1.resize(0);
	c2.resize(0);
	c3.resize(0);
	myfile.open("P0.txt");
   	i=0;
    while (myfile >> a)
    {
        P0[i]=a;
        ++i;
    }
    myfile.close();	
	
	Eigen::VectorXcd Ps(N_ele);
	Ps=Jth*P0;
	Ps=Ps/Ps.sum()/dv/da1/da2;	
	std::clock_t end=std::clock();
	std::cout<<(end-start)/1000000.<<"\n";
	
	std::cout << "calculate spectrum \n";
	Eigen::SparseMatrix <std::complex<double> > one(N_ele,N_ele);
	for (int i=0; i<N_ele; i++){
		one.insert(i,i)=1.;
	}
	Eigen::VectorXcd P (N_ele);
	Eigen::VectorXd m (n_omega);
	Eigen::BiCGSTAB <Eigen::SparseMatrix<std::complex<double> > > solver;
/*	Eigen::BiCGSTAB <Eigen::SparseMatrix<std::complex<double> >,Eigen::IncompleteLUT<std::complex<double> > > solver;
	solver.preconditioner().setDroptol(0.001);
    solver.preconditioner().setFillfactor(20);*/
    std::complex<double> eref=0.;
    std::complex<double> fac=0.;
    std::complex<double> sum=0;

	i=atoi(argv[1]);
	std::cout << i<< "\n";
	start= std::clock();
	if (omega[i]==0){
		right=(1.-rate*tref)*Ps-P0;
		solver.compute(-L-Jth);
		end=std::clock();
		std::cout<<(end-start)/1000000.<<"\n";	
		P=solver.solve(right);
		end=std::clock();
		std::cout<<(end-start)/1000000.<<"\n";
		sum=0;
		for (int k=0;k<N_a1;k++){
			for (int l=0;l<N_a2;l++){
				sum=sum+P.coeffRef(a1loc[k]+a2loc[l]+N_v-1);
			}
		}
		sum=sum*vv*dv*da1*da2;
		P=P+(-P.sum()*dv*da1*da2+tref*(tref*rate*0.5-1-sum))*P0;
		std::cout<<P.sum()*da1*dv*da2<<std::endl;
	}
	else{
		eref=std::cos(omega[i]*tref)-1j*std::sin(omega[i]*tref);
		fac=eref-rate/c_omega[i]*(1.-eref);
		right=fac*Ps-P0;
		solver.compute(c_omega[i]*one-L-eref*Jth);
		end=std::clock();
		std::cout<<(end-start)/1000000.<<"\n";	
		P=solver.solve(right);
		end=std::clock();
		std::cout<<(end-start)/1000000.<<"\n";
		if (omega[i]<6.283185307179586){
			sum=0;
			for (int k=0;k<N_a1;k++){
				for (int l=0;l<N_a2;l++){
					sum=sum+P.coeffRef(a1loc[k]+a2loc[l]+N_v-1);
				}
			}
			sum=sum*vv*dv*da1*da2;
			P=P+(-P.sum()*dv*da1*da2+tref*(tref*rate*0.5-1-sum))*P0;
		}
	}

	m[i]=0;
	for (int k=0;k<N_a1;k++){
		for (int l=0;l<N_a2;l++){
			m[i]=m[i]+std::real(P.coeffRef(a1loc[k]+a2loc[l]+N_v-1));
		}
	}
	m[i]=2.*m[i]*dv*da1*da2*vv;
	outFile.open("m_"+std::to_string(i)+".txt");
	outFile<<m[i]<<"\n";
	outFile<<omega[i]/6.283185307179586<<"\n";
	outFile.close();

	return 0;
}
